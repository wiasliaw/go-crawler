package db

import (
	"database/sql"
	"fmt"
	"log"
	"os"
	"strings"

	// posgres driver
	_ "github.com/jackc/pgx/v4/stdlib"
)

const (
	createDbSQL string = `
		CREATE TABLE IF NOT EXISTS crawl (
			url_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			url_hash VARCHAR(32) NOT NULL
		);
		CREATE UNIQUE INDEX IF NOT EXISTS url_idx ON crawl (url_hash);
	`
	insertSQL    string = "INSERT INTO crawl (url_hash) VALUES ('%s');"
	queryAllSQL  string = "SELECT * FROM crawl;"
	queryByIDSQL string = "SELECT * FROM crawl c WHERE c.url_hash = '%s'"
)

// New returns a reference of database instance
func New() *Database {
	connStr := fmt.Sprintf(
		"host=%s user=%s password=%s dbname=%s sslmode=disable",
		os.Getenv("DB_HOST"),
		os.Getenv("DB_USER"),
		os.Getenv("DB_PSWD"),
		os.Getenv("DB_NAME"),
	)

	postgres, err := sql.Open("pgx", connStr)
	if err != nil {
		log.Fatal(err)
	}

	postgres.SetMaxOpenConns(20)

	instance := &Database{
		db: postgres,
	}

	return instance
}

// Database is a struct for postgres db
type Database struct {
	db *sql.DB
}

// Init is a function for initialize database
func (d *Database) Init() {
	_, err := d.db.Exec(createDbSQL)
	if err != nil {
		log.Fatal(err)
	}
}

// Close is a function for close connection
func (d *Database) Close() {
	d.db.Close()
}

// Insert is a function for insert an object into database
func (d *Database) Insert(urlHash string) {
	defer func() {
		if r := recover(); r != nil {
			log.Println("Cover", r)
		}
	}()

	tx, err := d.db.Begin()
	if err != nil {
		panic(err)
	}

	_, execErr := tx.Exec(fmt.Sprintf(insertSQL, urlHash))
	if execErr != nil {
		_ = tx.Rollback()
		panic(execErr)
	}

	if err := tx.Commit(); err != nil {
		panic(err)
	}
}

// Query is a function for query data from database according to hash
func (d *Database) Query(urlHash string) []Record {
	var sql string
	if strings.Compare(urlHash, "all") == 0 {
		sql = queryAllSQL
	} else {
		sql = fmt.Sprintf(queryByIDSQL, urlHash)
	}

	rows, err := d.db.Query(sql)
	if err != nil {
		log.Fatal(err)
	}

	records := make([]Record, 0)
	for rows.Next() {
		var r Record
		if err := rows.Scan(&r.ID, &r.URLHash); err != nil {
			log.Fatal(err)
		}
		records = append(records, r)
	}

	return records
}
